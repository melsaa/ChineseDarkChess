#pragma once

#include <vector>
#include <assert.h>
#include <iostream>
#include <bitset>
#include "types.h"

namespace DarkChess {

extern uint64_t cannonMasks[SQUARE_NB];
extern uint64_t cannonHTable[SQUARE_NB][256];
extern uint64_t cannonVTable[SQUARE_NB][256];

const uint64_t cannonHMagics[SQUARE_NB] = {
  0x8080040048230214ULL,
  0x1040001012005012ULL,
  0x10200911292B09ULL,
  0x4280810002520002ULL,
  0x1100010482000000ULL,
  0x60800008002401ULL,
  0x2122000400001400ULL,
  0x98004400004008ULL,
  0x8800011000A102ULL,
  0x80200A8040100001ULL,
  0x4011040000008040ULL,
  0x4234100008118580ULL,
  0x404080080A041090ULL,
  0x22082001101C006ULL,
  0x899000410040030ULL,
  0x2201010080200A00ULL,
  0x3080100080040124ULL,
  0x1081090000001190ULL,
  0x20088000010020ULL,
  0x420100089000008ULL,
  0x2210020000A1100ULL,
  0x4011808200040002ULL,
  0x20804000500A0ULL,
  0xA401802040052284ULL,
  0x200102000400000ULL,
  0x6100100480A04ULL,
  0x441610248AA0181ULL,
  0x804800219808184ULL,
  0x801000020000001ULL,
  0x4880801400404ULL,
  0xE120040110041140ULL,
  0x2400001082005200ULL
};

const uint64_t cannonVMagics[SQUARE_NB] = {
  0x8010204021800000ULL,
  0x420102048048A0ULL,
  0x81042000804008ULL,
  0x10020402004020ULL,
  0x480240800A91000ULL,
  0x84020880100004ULL,
  0x1002010600000400ULL,
  0x8001020808002000ULL,
  0x20030880A006010ULL,
  0x40241001012800ULL,
  0x81020114108040ULL,
  0x1000A0408008400ULL,
  0x4420080400180200ULL,
  0x4040020811000202ULL,
  0x6002A120000101ULL,
  0x4408005002080001ULL,
  0x102004012000410ULL,
  0x2049002001000281ULL,
  0x41802000080200ULL,
  0x20801401404100ULL,
  0x314080020008000CULL,
  0xA408200400400000ULL,
  0x385220040C006081ULL,
  0x2049100410000100ULL,
  0x2040610000080012ULL,
  0x2020C10000300CE0ULL,
  0x9081060000C06080ULL,
  0x88D90000020911ULL,
  0x208021000104204ULL,
  0x60401000000010ULL,
  0x3010082000300014ULL,
  0x300A031000204484ULL
};

const int cBits[SQUARE_NB] = {
  8, 7, 7, 8,
  7, 6, 6, 7,
  7, 6, 6, 7,
  7, 6, 6, 7,
  7, 6, 6, 7,
  7, 6, 6, 7,
  7, 6, 6, 7,
  8, 7, 7, 8
};

uint64_t random_uint64();

uint64_t random_uint64_fewbits();

uint64_t index_to_uint64(int index, int bits, uint64_t mask);

uint64_t getBlockersFromIndex(int index, uint64_t mask);

uint64_t cmask(Square sq);

uint64_t getCannonAttack(Square sq, uint64_t blockers);

uint64_t getCannonAttackSlow(Square sq, uint64_t blockers, int dir);

int transform(uint64_t b, uint64_t magic, int bits);

uint64_t find_magic(Square sq, int m, int dir);

void initCannonMasks();

void initCannonMagic();

void initCannonMagicTable();

} // namespace DarkChess